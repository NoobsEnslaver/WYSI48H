<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="RU" xml:lang="RU">
<head>
<title>Пишем интерпретатор Scheme за 48 часов: боевое введение в Haskell</title>
<!-- 2016-02-22 Mon 13:08 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Jonathan Tang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Пишем интерпретатор Scheme за 48 часов: боевое введение в Haskell</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Первые шаги: компиляция и запуск</a>
<ul>
<li><a href="#sec-1-1">1.1. Упрежнения</a></li>
</ul>
</li>
<li><a href="#sec-2">2. Парсинг</a>
<ul>
<li><a href="#sec-2-1">2.1. Простейший парсер</a></li>
<li><a href="#sec-2-2">2.2. Обрабатываем пробелы</a></li>
<li><a href="#sec-2-3">2.3. Возвращаем значение</a></li>
<li><a href="#sec-2-4">2.4. Рекурсивный парсинг: обрабатываем списки и многоточия</a></li>
<li><a href="#sec-2-5">2.5. Упрежнения</a></li>
</ul>
</li>
<li><a href="#sec-3">3. Выполнение, часть 1</a>
<ul>
<li><a href="#sec-3-1">3.1. Простейший "выполнитель"</a></li>
<li><a href="#sec-3-2">3.2. Основы выполнения кода: примитивы</a></li>
<li><a href="#sec-3-3">3.3. Добавления простых примитивов</a></li>
<li><a href="#sec-3-4">3.4. Упражнения</a></li>
</ul>
</li>
<li><a href="#sec-4">4. Обнаружение ошибок и исключения</a></li>
<li><a href="#sec-5">5. Выполнение, часть 2</a>
<ul>
<li><a href="#sec-5-1">5.1. Новые примитивы: частичное применение</a></li>
<li><a href="#sec-5-2">5.2. Условия: сопоставление с образцом 2</a></li>
<li><a href="#sec-5-3">5.3. Примитивы для работы со списками: car, cdr, cons</a></li>
<li><a href="#sec-5-4">5.4. equal? и слабая типизация: гетерогенные списки</a></li>
<li><a href="#sec-5-5">5.5. Упражнения</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
<b>Краткое вступление</b>
</p>

<p>
Большинство учебников по Haskell в интернете больше похожи на
справочники. Они описывают синтаксис языка, некоторые его конструкции,
и некоторые простые функции для работы с командной строкой. А вот о
том, как писать функциональные, полезные программы, упоминается в
конце, а иногда и вообще опускается.
</p>

<p>
У этого учебника другой подход. Вы начнёте с изучения аргументов
командной строки и их разбора, и дойдёте до написания
полнофункционального интерпретатора языка программирования Scheme, в
котором будет реализовано большое подмножество <a href="http://www.schemers.org/Documents/Standards/R5RS/HTML">R5RS Scheme</a> А по ходу
вы изучите систему ввода/вывода, mutable state, динамическую
типизацию, обработку ошибок, и разбор текстов. А когда вы закончите,
вы достаточно свободно будете владеть и Haskell, и Scheme.
</p>

<p>
Учебник предназначен для тех:
</p>
<ol class="org-ol">
<li>кто уже знает Лисп (особенно диалект Scheme) и хочет изучить
Haskell;
</li>
<li>кто не владеет ни одним языком программирования, но имеет большой
запас базовых знаний и знаком с компьютерами.
</li>
</ol>

<p>
Тем, кто использует процедурные и объектно-ориентированные языки
(такие как C, Java, Python), следует забыть многое, что вы уже знаете
о программировании. Haskell очень сильно отличается от этих языков, и
требует совершенно другого образа мышления при написании
программ. Будет лучше, если вы начнёте изучать это руководство с
чистого листа, и не будете пытаться сравнивать Haskell с императивными
языками, потому как многие концепции в них (классы, функции, 'return')
имеют совершенно иные значения в Haskell.
</p>

<p>
Каждый урок использует код, написанный в предыдущих главах. Поэтому
уроки следует изучать по порядку.
</p>

<p>
Мы подразумеваем, что вы используете <a href="http://www.haskell.org/ghc/">GHC</a> в качестве компилятора. Вы
также можете использовать <a href="http://www.haskell.org/hugs/">Hugs</a> , но, возможно, для него вам придется
скачать дополнительные библиотеки.
</p>

<p>
Исходные коды из учебника доступны здесь: <a href="http://jonathan.tang.name/files/scheme_in_48/code/">исходные коды</a>.
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Первые шаги: компиляция и запуск</h2>
<div class="outline-text-2" id="text-1">
<p>
Для начала, вам нужно установить GHC. Под Linux он скорее всего уже
установлен, если это не так, то его можно установить с помощью системы
пакетов вашего дистрибутива. Скорее всего, проще будет установить
бинарный пакет, кроме тех случаев, когда вы действительно знаете, что
делаете. Его можно скачать и установить также, как и любой другой
пакет. Этот учебник был написан на Linux, но всё должно работать и под
Windows, при условии, что вы умеете пользоваться командной строкой.
</p>

<p>
Для пользователей UNIX (или <a href="http://www.gnu.org/software/emacs/windows/ntemacs.html">Windows Emacs</a>) существует отличный <a href="http://haskell.org/haskell-mode/">режим
для Emacs</a>, включающий в себя подсветку синтаксиса и автоматическое
выравнивание. Пользователи Windows могут использовать Блокнот
(Notepad) или любой другой текстовый редактор, но вам нужно быть
осторожнее с отступами. Пользователи <a href="http://www.eclipse.org/">Eclipse</a>, возможно, захотят
попробовать <a href="http://eclipsefp.sourceforge.net/haskell/">Function Programming</a> плагин. Наконец, существует и
<a href="http://www.haskell.org/visualhaskell/">Haskell-плагин</a> для Visual Studio, который использует компилятор GHC.
</p>

<p>
Теперь настало время написать вашу первую программу на Haskell. Эта
программа читает имя с командной строки и выводит на экран
приветствие. Создайте файл, который оканчивается на '.hs', и наберите
в нём следующий текст. Убедитесь, что вы правильно расставили отступы,
иначе программа может не компилироваться.
</p>

<div class="org-src-container">
<label class="org-src-name">Your first Haskell program (hello.hs)</label>
<pre class="src src-haskell" id="fig:hello-hs"><span style="color: #8ac6f2; font-weight: bold;">module</span> <span style="color: #92a65e; font-weight: bold;">Main</span> <span style="color: #8ac6f2; font-weight: bold;">where</span>
<span style="color: #8ac6f2; font-weight: bold;">import</span> <span style="color: #92a65e; font-weight: bold;">System.Environment</span>

<span style="color: #cae682;">main</span> <span style="color: #cae682;">::</span> <span style="color: #92a65e; font-weight: bold;">IO</span> <span style="color: #92a65e; font-weight: bold;">()</span>
<span style="color: #cae682;">main</span> <span style="color: #cae682;">=</span> <span style="color: #8ac6f2; font-weight: bold;">do</span>
  args <span style="color: #cae682;">&lt;-</span> getArgs
  putStrLn (<span style="color: #95e454;">"Hello, "</span> <span style="color: #cae682;">++</span> args <span style="color: #cae682;">!!</span> 0)
</pre>
</div>

<p>
Теперь давайте рассмотрим, что мы написали. Первые две строки
означают, что мы создаём модуль с именем Main, который импортирует
модуль <a href="http://www.haskell.org/onlinereport/system.html">System</a>. Каждая программа на Haskell начинается с действия,
которое называется <code>main</code>, определенного в модуле Main. Этот модуль
может импортировать другие модули, но он обязательно должен
присутствовать, чтобы компилятор смог создать исполяемый файл. Haskell
чувствителен к регистру символов: название модуля всегда начинается с
большой буквы, определения всегда с маленькой.
</p>

<p>
Строка <code>main :: IO ()</code> содержит объявление типа, в ней
говорится, что действие <code>main</code> имеет тип <code>IO ()</code>. В Haskell тип
указывать не обязательно: компилятор выведет его автоматически, и
выдаст ошибку, только если его тип будет отличаться от заданного
вами. Для ясности я буду всегда объявлять тип.
</p>

<p>
Тип IO в некотором роде пример того, что называется <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B0_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)">монада</a>, за
страшным названием которой скрывается не такое уж страшное понятие. По
сути, монада - это способ сказать "мы будем определенным образом
"тянуть" за собой и комбинировать некую дополнительную информацию,
которая "прикреплена" к необходимым нам данным, и которая не нужна
большинству функций". Каким именно образом мы "тянем" за собой эту
дополнительную информацию и комбинируем наши значения, определяется
каждым конкретным монадическим типом; "основные" же данные могут
изменяться или конвертироваться из одного типа в другой при помощи
обычных функций, которые мы вызываем из монады, не затрагивая при этом
дополнительную информацию, "прикрепленную" к ним. При этом принцип
монадического "конвейера", передающего данные с предыдущего шага на
последующий шаг, во всех монадах одинаков.
</p>

<p>
В нашем примере, "дополнительная информация" это действия
ввода/вывода, которые должны быть выполнены с использованием
переданных значений, а также пустое значение, которое в коде
представлено как <code>()</code>. И <code>IO [String]</code>, и <code>IO ()</code> относятся к
одному типу монады <code>IO</code> с разными базовыми типами, что означает, что
они представляют из себя действия ввода/вывода, оперирующие значениями
разных типов: <code>[String]</code> и <code>()</code>. Подобные монадные значения, созданные
из базовых типов, упакованных внутрь монады, часто называют
"действиями", потому что простейший способ представить себе монаду
<code>IO</code> - думать о ней, как о последовательности действий, каждое из
которых может оперировать с переданными значениями базовых типов,
взаимодействуя с внешним миром.
</p>

<p>
Haskell - это декларативный язык: вместо указания компьютеру
последовательности инструкций для выполнения, вы даете ему набор
определений, как нужно выполнять каждую из функций, которые могут ему
понадобиться. Эти определения состоят из различных комбинации действий
и функций. Компилятор вычисляет, в каком порядке следует выполнять
функции, чтобы получить конечный результат.
</p>

<p>
Haskell - это декларативный язык: вместо указания компьютеру
последовательности инструкций для выполнения, вы даете ему набор
определений, как нужно выполнять каждую из функций, которые могут ему
понадобиться. Эти определения состоят из различных комбинации действий
и функций. Компилятор вычисляет, в каком порядке следует выполнять
функции, чтобы получить конечный результат.
</p>

<p>
Чтобы написать одно из таких определений, вы просто задаете его в виде
уравнений. Левая часть определяет имя и, возможно, один или несколько
образцов (объяснено далее), которые связываются с переменными. Правая
часть определяет некоторую комбинацию из других определений, которые
говорят компьютеру, что делать, когда он встречает их имя в
определении. Эти уравнения внешне очень похожи на обычные уравнения из
алгебры: вы всегда можете подставить правую часть вместо левой в
тексте программы и результат выполнения будет точно таким
же. Называемое "ссылочной прозрачностью", это свойство делает чтение и
понимание программ на Haskell значительно легче, чем на других языках.
</p>

<p>
Как мы определяем действие <code>main</code>? Мы знаем, что оно должно быть
действием <code>IO ()</code>, ведь мы хотим читать аргументы из командной
строки и выводить на печать результаты, используя <code>()</code>, или пустое
значение, в конце концов.
</p>

<p>
Есть два способа создать действие ввода/вывода (либо напрямую, либо
вызывая функцию, которая сделает это):
</p>
<ol class="org-ol">
<li>Передать обычное значение в монаду <code>IO</code>, используя функцию <a href="http://www.haskell.org/onlinereport/standard-prelude.html#$tMonad">return</a>.
</li>
<li>Объединить два существующих действия ввода/вывода.
</li>
</ol>

<p>
Так как мы хотим сделать две вещи, мы выберем второй
подход. Предопределенное действие <a href="http://www.haskell.org/ghc/docs/6.4/html/libraries/base/System.Environment.html#v%253AgetArgs">getArgs</a> читает аргументы командной
строки и передает их далее, как список строк. Предопределенная функция
<a href="http://www.haskell.org/onlinereport/standard-prelude.html#$vputStrLn">putStrLn</a> принимает строку и создает действие, которое выводит эту
строку на консоль.
</p>

<ol class="org-ol">
<li>имя &lt;- действие1
</li>
<li>действие2
</li>
</ol>

<p>
Первая форма связывает результат <i>действие1</i> с <i>имя</i>, чтобы он стал
доступен в следующих действиях. Например, если <i>действие1</i> имеет тип
<code>IO</code> <code>[String]</code> (действие ввода/вывода, возвращающее список строк, как
<code>getArgs</code>), то имя будет связано во всех последующих действиях со
списком строк, который будет передан через использование "связующего"
оператора <code>&gt;&gt;=</code> . Вторая форма просто выполняет <i>действие2</i>, переходя
к следующей строке (она обязательно должна существовать) через
оператор <code>&gt;&gt;</code>. Оператор связывания имеет разную семантику в разных
монадах: в случае монады <code>IO</code>, он выполняет действие последовательно,
производя разного рода побочные эффекты, как результаты
действий. Поскольку семантика композиции действий зависит от текущей
используемой монады, вы не можете смешивать действия из монад разных
типов в одном <code>do-block</code> - может быть использована только монада <code>IO</code>
(Можете представлять себе это так, как будтно вычисления и данные
"текут по трубе <code>IO</code>" и чтобы их использовать, нужно будет их оттуда
сначала извлечь).
</p>

<p>
Конечно, эти действия могут могут сами вызывать функции или сложные
выражения, передавая результаты их вычисления(либо через вызов функции
<code>return</code>, либо некоторой функции, которая в последствии сделает то же
самое). В наше примере, мы сначала берем первый элемент из списка
аргументов (с индексом 0, <code>args !! 0</code>), прилепляем его в конец
строки "Hello, " ("<code>Hello</code>, " <code>++</code>), и, наконец, передаем результат
<code>putStrLn</code>, которая создает новое действие ввода/вывода, следующей в
do-block.
</p>

<p>
Новое только что созданное действие, представляющее из себя комбинацию
последовательных действий, как описано выше, сохранено под именем
<code>main</code> с типом <code>IO ()</code>. Система Haskell находит это определение и
выполняет действие в нем.
</p>

<p>
Строки представлены в Haskell списком символов, так что вы можете
применять к ним любые функции для работы со списками. Полная таблица
стандартных операторов и их порядка:
</p>

<table id="tbl:basic-operators" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 1:</span> Базовые операторы</caption>

<colgroup>
<col  class="left" />

<col  class="right" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Оператор(ы)</th>
<th scope="col" class="right">Порядок</th>
<th scope="col" class="left">Ассоциативность</th>
<th scope="col" class="left">Описание</th>
<th scope="col" class="left">&#xa0;</th>
<th scope="col" class="left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><code>.</code></td>
<td class="right">9</td>
<td class="left">Правая</td>
<td class="left">Композиция функций</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><code>!!</code></td>
<td class="right">9</td>
<td class="left">Левая</td>
<td class="left">Взятие индекса в списке</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><code>^</code>, <code>^^</code>, <code>**</code></td>
<td class="right">8</td>
<td class="left">Правая</td>
<td class="left">Возведение в степень (целое, дробное, и действительное число)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><code>*</code>, <code>/</code></td>
<td class="right">7</td>
<td class="left">Левая</td>
<td class="left">Умножение, Деление</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><code>+</code>, <code>-</code></td>
<td class="right">6</td>
<td class="left">Левая</td>
<td class="left">Сложение, Вычитание</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><code>:</code></td>
<td class="right">5</td>
<td class="left">Правая</td>
<td class="left">Cons (конструктор списков)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><code>++</code></td>
<td class="right">5</td>
<td class="left">Левая</td>
<td class="left">Склеивание списков</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><code>`elem`</code>, <code>`notElem`</code></td>
<td class="right">4</td>
<td class="left">Левая</td>
<td class="left">Предикат пренадлежности к списку</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">==,/=,&lt;,&lt;=,&gt;,&gt;=</td>
<td class="right">4</td>
<td class="left">Левая</td>
<td class="left">Проверки на равенство, не равенство, и другие операции сравнения</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><code>&amp;&amp;</code></td>
<td class="right">3</td>
<td class="left">Правая</td>
<td class="left">Логическое И</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">&vert;&vert;</td>
<td class="right">2</td>
<td class="left">Правая</td>
<td class="left">Логическое ИЛИ</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><code>&gt;&gt;=</code>, <code>&gt;&gt;</code></td>
<td class="right">1</td>
<td class="left">Левая</td>
<td class="left">Монадное связывание, Монадное связывание (с передачей результата в следующую функцию)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">=&lt;&lt;</td>
<td class="right">1</td>
<td class="left">Левая</td>
<td class="left">Обратное монадное связывание (аналогично предыдущему, но аргументы в обратном порядке)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><code>$</code></td>
<td class="right">0</td>
<td class="left">Правая</td>
<td class="left">Инфиксное применение функции (аналогично "f x", но правоассоциативно, а не левоассоциативно, как обычно)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
Чтобы скомпилировать и запустить программу, введите примерно такие
команды:
</p>

<pre class="example">
[USER ~]$ ghc -o hello_you hello.hs
[USER ~]$ ./hello_you Jonathan
</pre>
<p>
Опция <code>-o</code> указывает имя исполняемого файла, который получается после
компиляции, а дальше вы просто указываете имя файла с исходным текстом
Haskell.
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Упрежнения</h3>
<div class="outline-text-3" id="text-1-1">
<ol class="org-ol">
<li>Измените программу так, чтобы она читала два аргумента из командной
строки выводила сообщение, используя оба из них
</li>
<li>Измените программу так, чтобы она выполняла простую арифметическую
операцию с двумя аргументами и выводила результат. Можете
использовать <a href="http://www.haskell.org/onlinereport/standard-prelude.html#$vread">read</a>, чтобы преобразовать значения из строки в число,
и <a href="http://www.haskell.org/onlinereport/standard-prelude.html#$tShow">show</a>, чтобы преобразовать число обратно в строку. Попробуйте
поиграть с разными арифметическими операциями.
</li>
<li>getLine это действие ввода/вывода, которое читает строку с консоли
и возвращает ее в виде строки. Измените программу так, чтобы
запрашивала имя, читала введенное значение, а затем выводила его
вместо переданных параметров
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Парсинг</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> Простейший парсер</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Давайте попробуем написать очень простой синтаксический анализатор. Мы
будем использовать библиотеку <a href="http://www.cs.uu.nl/~daan/download/parsec/parsec.html">Parsec</a> (Установите parsec, если вы еще
не сделали этого, самостоятельно или в составе Haskell Platform.).
</p>

<p>
Начнем мы с добавления следующей строки в секцию импорта:
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #8ac6f2; font-weight: bold;">import</span> <span style="color: #92a65e; font-weight: bold;">Text.ParserCombinators.Parsec</span> <span style="color: #8ac6f2; font-weight: bold;">hiding</span> (spaces)
</pre>
</div>

<p>
Это позволит нам использовать функции из библиотеки Parsec, за
исключением функции spaces, потому что ее имя будет конфликтовать с
функцией, которую мы определим чуть позднее.  
</p>

<p>
Теперь определим синтаксический анализатор, который будет распознавать
символы, разрешенные для определения идентификаторов в Scheme:
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #cae682;">symbol</span> <span style="color: #cae682;">::</span> <span style="color: #92a65e; font-weight: bold;">Parser</span> <span style="color: #92a65e; font-weight: bold;">Char</span>
<span style="color: #cae682;">symbol</span> <span style="color: #cae682;">=</span> oneOf <span style="color: #95e454;">"!#$%&amp;|*+-/:&lt;=&gt;?@^_~"</span>
</pre>
</div>

<p>
Это еще один пример монады: в данном случае «дополнительная
информация», которая скрыта, это информация о позиции в входном потоке
данных, о предыдущей записи, о первом и последующих наборах и
т. д. Parsec позаботится обо всем за нас. Нам нужно лишь
воспользоваться функцией <a href="http://www.cs.uu.nl/~daan/download/parsec/parsec.html#oneOf">oneOf</a> из библиотеки Parsec, и она разберет
символы в переданной ей строке. Parsec предоставляет множество готовых
синтаксических анализаторов: например, <a href="http://www.cs.uu.nl/~daan/download/parsec/parsec.html#letter">letter</a> и <a href="http://www.cs.uu.nl/~daan/download/parsec/parsec.html#digit">digit</a>. Вы так же
можете создавать более сложные синтаксические анализаторы из более
простых.
</p>

<p>
Определим функцию, которая будет вызывать наш синтаксический
анализатор и отлавливать все возможные ошибки:
</p>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #cae682;">readExpr</span> <span style="color: #cae682;">::</span> <span style="color: #92a65e; font-weight: bold;">String</span> <span style="color: #cae682;">-&gt;</span> <span style="color: #92a65e; font-weight: bold;">String</span>
<span style="color: #cae682;">readExpr</span> input <span style="color: #cae682;">=</span> <span style="color: #8ac6f2; font-weight: bold;">case</span> parse symbol <span style="color: #95e454;">"lisp"</span> input <span style="color: #8ac6f2; font-weight: bold;">of</span>
  <span style="color: #92a65e; font-weight: bold;">Left</span> err <span style="color: #cae682;">-&gt;</span> <span style="color: #95e454;">"No match: "</span> <span style="color: #cae682;">++</span> show err
  <span style="color: #92a65e; font-weight: bold;">Right</span> val <span style="color: #cae682;">-&gt;</span> <span style="color: #95e454;">"Found value"</span>
</pre>
</div>

<p>
Из сигнатуры функции вы можете видеть, что <code>readExpr</code> это функция (-&gt;)
из String в String. Мы назвали параметр <code>input</code> и передали его дальше,
вместе с синтаксическим анализатором <code>symbol</code>, определенным ранее, в
функцию <a href="http://www.cs.uu.nl/~daan/download/parsec/parsec.html#parse">parse</a> из библиотеки Parsec. Второй параметр функции <code>nparse</code>
это имя для передаваемых данных. Оно используется для вывода сообщений
об ошибках.
</p>

<p>
<code>parse</code> может вернуть либо разобранное значение, либо ошибку, так что
нам нужно иметь возможность отлавливать ошибки. Следуя принятым в
Haskell соглашениям, Parsec возвращает тип <a href="http://www.haskell.org/onlinereport/standard-prelude.html#$tEither">Either</a>, в котором
конструктор <code>Left</code> используется для указания на ошибку, а конструктор
<code>Right</code> для возврата нормального значения.
</p>

<p>
Используем конструкцию <code>case...of</code>, чтобы проверить, какой результат
вернула функция parse. Если мы получили значение Left (ошибка), то
присваиваем ошибке имя <code>err</code> и возвращаем «No match» с текстовым
представлением ошибки. Если же мы получили значение Right, то
присваиваем значению имя <code>val</code> и, игнорируя его, возвращаем строку
«Found value».
</p>

<p>
Конструкция <code>case...of</code> это пример сравнения с шаблоном, которое мы
рассмотрим значительно подробнее позднее.
</p>

<p>
Напоследок, нам нужно изменить нашу функцию так, чтобы вызывать
<code>readExpr</code> и выводить на печать результат (необходимо добавить <code>import
System</code> в начале файла):
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #cae682;">main</span> <span style="color: #cae682;">::</span> <span style="color: #92a65e; font-weight: bold;">IO</span> <span style="color: #92a65e; font-weight: bold;">()</span>
<span style="color: #cae682;">main</span> <span style="color: #cae682;">=</span> <span style="color: #8ac6f2; font-weight: bold;">do</span> args <span style="color: #cae682;">&lt;-</span> getArgs
          putStrLn (readExpr (args <span style="color: #cae682;">!!</span> 0))
</pre>
</div>

<p>
В итоге наша программа должна преобрести следующий вид:
</p>
<div class="org-src-container">
<label class="org-src-name">Простейший парсер (simpleparser1.hs)</label>
<pre class="src src-haskell"><span style="color: #8ac6f2; font-weight: bold;">module</span> <span style="color: #92a65e; font-weight: bold;">Main</span> <span style="color: #8ac6f2; font-weight: bold;">where</span>

<span style="color: #8ac6f2; font-weight: bold;">import</span> <span style="color: #92a65e; font-weight: bold;">System.Environment</span>(getArgs)
<span style="color: #8ac6f2; font-weight: bold;">import</span> <span style="color: #92a65e; font-weight: bold;">Text.ParserCombinators.Parsec</span> <span style="color: #8ac6f2; font-weight: bold;">hiding</span> (spaces)

<span style="color: #cae682;">main</span><span style="color: #cae682;">::</span><span style="color: #92a65e; font-weight: bold;">IO()</span>
<span style="color: #cae682;">main</span><span style="color: #cae682;">=</span> <span style="color: #8ac6f2; font-weight: bold;">do</span>
  args <span style="color: #cae682;">&lt;-</span> getArgs
  putStrLn (readExpr<span style="color: #cae682;">$</span> args <span style="color: #cae682;">!!</span> 0)

<span style="color: #cae682;">symbol</span> <span style="color: #cae682;">::</span> <span style="color: #92a65e; font-weight: bold;">Parser</span> <span style="color: #92a65e; font-weight: bold;">Char</span>
<span style="color: #cae682;">symbol</span> <span style="color: #cae682;">=</span> oneOf <span style="color: #95e454;">"!#$%&amp;|*+-/:&lt;=&gt;?@^_~"</span>

<span style="color: #cae682;">readExpr</span> <span style="color: #cae682;">::</span> <span style="color: #92a65e; font-weight: bold;">String</span> <span style="color: #cae682;">-&gt;</span> <span style="color: #92a65e; font-weight: bold;">String</span>
<span style="color: #cae682;">readExpr</span> input <span style="color: #cae682;">=</span> <span style="color: #8ac6f2; font-weight: bold;">case</span> parse symbol <span style="color: #95e454;">"lisp"</span> input <span style="color: #8ac6f2; font-weight: bold;">of</span>
    <span style="color: #92a65e; font-weight: bold;">Left</span> err <span style="color: #cae682;">-&gt;</span> <span style="color: #95e454;">"No match: "</span> <span style="color: #cae682;">++</span> show err
    <span style="color: #92a65e; font-weight: bold;">Right</span> val <span style="color: #cae682;">-&gt;</span> <span style="color: #95e454;">"Found value"</span>
</pre>
</div>

<p>
Теперь можно запустить нашу программу:
</p>
<pre class="example">
[USER ~]$ ghc -o simple_parser simpleparser1.hs
[USER ~]$ ./simple_parser $
Found value
[USER ~]$ ./simple_parser a
No match: "lisp" (line 1, column 1):
unexpected "a"
</pre>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> Обрабатываем пробелы</h3>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> Возвращаем значение</h3>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> Рекурсивный парсинг: обрабатываем списки и многоточия</h3>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5"><span class="section-number-3">2.5</span> Упрежнения</h3>
<div class="outline-text-3" id="text-2-5">
<div class="org-src-container">

<pre class="src src-haskell"></pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Выполнение, часть 1</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> Простейший "выполнитель"</h3>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> Основы выполнения кода: примитивы</h3>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> Добавления простых примитивов</h3>
</div>

<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> Упражнения</h3>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Обнаружение ошибок и исключения</h2>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Выполнение, часть 2</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> Новые примитивы: частичное применение</h3>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> Условия: сопоставление с образцом 2</h3>
</div>
<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> Примитивы для работы со списками: car, cdr, cons</h3>
</div>
<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4"><span class="section-number-3">5.4</span> equal? и слабая типизация: гетерогенные списки</h3>
</div>
<div id="outline-container-sec-5-5" class="outline-3">
<h3 id="sec-5-5"><span class="section-number-3">5.5</span> Упражнения</h3>
<div class="outline-text-3" id="text-5-5">
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Jonathan Tang</p>
<p class="date">Created: 2016-02-22 Mon 13:08</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.5.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
